<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
		xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
		layout:decorate="~{layout/layout}">
<head>
	<!-- 개별페이지 CSS 영역 -->
	<th:block layout:fragment="style">
		<style>
			section h3 {
				text-align: center;
			}
		
			.align_center {
				text-align: center;
			}
			
			#imgPreviewArea {
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
				width: 100%;
			}
			
			.div-img-preview {
				display: flex;
				flex-direction: column;
				align-items: center;			
			}
			
			.img-preview {
				width: 100px;
				height: 100px;
				display: block;
			}
		</style>
	</th:block>
</head>	
<body>
	<section layout:fragment="content">
		<h3>상품 상세정보</h3>
		<div id="registForm">
			<!-- 파일 업로드를 위해 form 태그 enctype 설정 -->
			<form th:action="@{/items}" th:object="${itemDTO}" method="post">
				<input type="hidden" th:field="*{id}" th:data-id="*{id}" id="itemId">
				<!-- 상품 정보 수정 요청은 "/items" 에 대한 PATCH 메서드 방식으로 요청을 전송해야함 -->
				<!-- form 태그의 method 속성은 "post" 방식으로 지정하고 폼 내부에서 히든 필드로 "_method" 속성값에 "patch" 지정하여 전송 -->
				<input type="hidden" name="_method" value="patch">
				<table border="1">
					<tr>
						<th>상품명</th>
						<td>
							<input type="text" th:field="*{itemNm}" required>
							<div class="error_msg" th:if="${#fields.hasErrors('itemNm')}" th:errors="*{itemNm}"></div>
						</td>
					</tr>
					<tr>
						<th>가격</th>
						<td>
							<input type="number" th:field="*{price}" required>
							<div class="error_msg" th:if="${#fields.hasErrors('price')}" th:errors="*{price}"></div>
						</td>
					</tr>
					<tr>
						<th>수량</th>
						<td>
							<input type="number" th:field="*{stockQty}" required>
							<div class="error_msg" th:if="${#fields.hasErrors('stockQty')}" th:errors="*{stockQty}"></div>
						</td>
					</tr>
					<tr>
						<th>카테고리</th>
						<td>
							<select th:field="*{category}">
								<option value="">카테고리 선택</option>
								<!-- 
								[ 타임리프 템플릿 페이지에서 자바 클래스(enum 포함) 를 직접 참조(접근)하는 방법 ]
								기본 문법 : ${T(패키지명.클래스명).메서드명()}
								=> enum 에서 제공하는 values() 메서드 호출하여 enum 이 가진 모든 값을 목록으로 표시(반복문 활용)
								   value 속성값은 반복 시 전달받은 enum 값을 그대로 사용, text 속성값은 enum 값의 label 필드값 사용
								-->
								<option th:each="cat : ${T(com.itwillbs.test5.item.constant.ItemCategory).values()}"
										th:value="${cat}"
										th:text="${cat.label}"></option>
							</select>
							<div class="error_msg" th:if="${#fields.hasErrors('category')}" th:errors="*{category}"></div>
						</td>
					</tr>
					<tr>
						<th>판매상태</th>
						<td>
							<select th:field="*{sellStatus}">
								<option value="">판매상태 선택</option>
								<option th:each="status : ${T(com.itwillbs.test5.item.constant.ItemSellStatus).values()}"
										th:value="${status}"
										th:text="${status.label}"></option>
							</select>
							<div class="error_msg" th:if="${#fields.hasErrors('sellStatus')}" th:errors="*{sellStatus}"></div>
						</td>
					</tr>
					<tr>
						<th>상세설명</th>
						<td>
							<textarea rows="4" cols="20" th:field="*{itemDetail}"></textarea>
							<div class="error_msg" th:if="${#fields.hasErrors('itemDetail')}" th:errors="*{itemDetail}"></div>
						</td>
					</tr>
					<tr>
						<th>첨부파일<br>(최대5개)</th>
						<td>
<!-- 							<input type="file" id="custom-file-input" name="itemImgFiles" accept="image/*" multiple> -->
<!-- 							<div id="imgPreviewArea"></div> -->
<!-- 							<div class="error_msg" id="fileErrorDiv" th:text="${errorMessage}"></div> -->
							<div class="itemImg" th:each="itemImgDTO : *{itemImgDTOList}">
								<!-- 1) img 태그로 서버상의 이미지 리소스에 직접 접근 -->
								<!-- => 클라이언트에서 정적 리소스 요청 시 기본적으로 루트(/)가 static 경로를 가리킴 -->
<!-- 								<img th:src="@{/images/1.jpg}" width="100" height="100" /> -->
								<!-- => 즉, src/main/resources/static/images 경로상의 리소스를 서버측으로 요청 -->
								
								<!-- 단, 클라이언트가 요청 불가능한 경로(정적 리소스 경로 제외)에 파일 업로드가 이루어지므로 -->
								<!-- 별도의 추가 설정을 통해 서버측으로 요청한 정보를 해석하고 실제 파일 위치를 탐색해야함 -->
								<!-- 2) 클라이언트에서 요청할 URL 을 가상의 축약 경로를 사용하여 요청하고 -->
								<!--    서버측에서 축약 경로에 대한 실제 경로로 변환하게 해당 요청 처리 후 응답 -->
								<!--    => 컨트롤러 측에서 별도의 매핑은 불필요하며 WebConfig 파일에 변환 처리 코드로 처리됨 -->
<!-- 								<img th:src="@{/files{imgLocation}/{imgName}(imgLocation=${itemImgDTO.imgLocation}, imgName=${itemImgDTO.imgName})}" title="/files 요청" width="100" height="100" /> -->
								
								<!-- ================================================================= -->
								<!-- [ 첨부파일 다운로드 ] -->
								<!-- 1) HTML5 에서 제공하는 하이퍼링크 download 속성 활용하여 클라이언트가 해당 리소스 다운로드를 직접 요청 후 처리 -->
<!-- 								<span th:text="${itemImgDTO.originalImgName}"></span> -->
<!-- 								<a th:href="@{/files{imgLocation}/{imgName}(imgLocation=${itemImgDTO.imgLocation}, imgName=${itemImgDTO.imgName})}" th:download="${itemImgDTO.originalImgName}"> -->
<!-- 									<input type="button" class="btn-download" value="다운로드"> -->
<!-- 								</a> -->
								
								<!-- 2) 클라이언트 상에서 실제 파일명을 노출시키지 않고 아이디값만으로 서버측으로 다운로드 요청을 전송하여 -->
								<!--    서버측에서 요청에 따른 파일 전송 처리까지 수행하는 방법(= 다운로드 횟수 누적 등의 부가 작업도 처리 가능) -->
								<!--    => 컨트롤러에서 처리 필요! -->
								<span th:text="${itemImgDTO.originalImgName}"></span>
								<a th:href="@{/items/download/{id}(id=${itemImgDTO.id})}">
									<input type="button" class="btn-download" value="다운로드">
								</a>
							</div>
						</td>
					</tr>
					<tr>
						<td colspan="2" class="align_center">
							<input type="submit" value="수정">
							<input type="button" value="삭제" onclick="confirmDelete()">
<!-- 							<input type="button" value="삭제" id="btnRemove" th:data-id="*{id}"> -->
							<input type="button" value="취소">
						</td>
					</tr>
				</table>
			</form>
		</div>
	</section>
	
	<!-- 개별 페이지의 자바스크립트 영역 -->
	<th:block layout:fragment="myScript">
		<script>
			$(function() {
				// 첨부파일 선택하지 않고 등록 요청 시 서버로부터 전달받은 오류메세지를 자바스크립트로 출력
// 				const msg = "${errorMessage}";
// 				console.log("msg : " + msg);
				// => 주의! 타임리프 템플릿 페이지에서 자바스크립트 사용 시
				//    ${} 활용하여 서버로부터 전달받은 속성에 접근하려 할 경우
				//    정상적으로 파싱이 되지 않고 ${} 기호가 단순 문자열로 취급됨
				// => 이 때, 타임리프 객체{} 앞 뒤로 [[ 기호와 ]] 기호를 감싸면 정상적으로 파싱됨
				const msg = "[[${errorMessage}]]";
				if(msg && msg.trim() != "") {
// 					console.log("msg : " + msg);
					alert(msg);
				}
				// =====================================================================
				// 파일 선택 요소의 change 이벤트 핸들링
				$("#custom-file-input").change(function(event) {
					// 파일 선택 요소에서 선택된 파일 목록 객체 가져오기
					const files = event.target.files;
					console.log(files);
					// -------------------------------------------------
					// 참고) 파일 목록에서 이미지 파일들만 필터링(미리보기 대상으로 이미지 파일만 선택하기 위함)
					let imageFiles = Array.from(files).filter(f => f.type.startsWith("image/"));
				
					// 선택된 파일 갯수 제한(현재는 이미지 파일 목록만으로 제한)
					// => x개를 초과하면 경고 출력 후 x개 파일을 제외한 나머지 파일 버림
					const fileCountLimit = 5;
					if(imageFiles.length > fileCountLimit) { // 파일 갯수가 5개보다 많을 경우
						alert("최대 첨부 가능한 갯수 : " + fileCountLimit);
						imageFiles = imageFiles.slice(0, fileCountLimit); // 0부터 파일 갯수만큼 남기고 버림
						console.log(imageFiles); // 5개만 남은 목록 출력됨
					}
					// --------------------------------------------------
					// 미리보기1) 이미지 프리뷰 영역 초기화
					$("#imgPreviewArea").html("");
					
					// 기존 파일 선택 영역을 교체할 새로운 파일 목록 객체 변경에 사용되는 DataTransfer 객체 생성
					let newFiles = new DataTransfer();
					
					// 이미지 파일 갯수만큼 반복문 수행
					$.each(imageFiles, function(index, file) {
						// 현재 반복중인 파일 1개를 새로운 DataTransfer 객체에 추가
						newFiles.items.add(file);
						// ------------------------
						// 미리보기2) FileReader 객체 생성
						let reader = new FileReader();
					
						// 미리보기3) FileReader 객체의 onload 이벤트 핸들링
						// => 아래쪽의 reader.readAsDataURL(file) 코드가 실행되어 이미지 파일을 로딩 완료할 경우 이벤트 발생함
						reader.onload = function(e) {
							console.log(e.target.result);
							
							// 미리보기 3-1) 미리보기 HTML 요소 생성
							// => <img> 태그를 활용하여 읽어온 이미지(e.target.result)를 src 속성에 전달
							const imgPreview = $(`<div class="div-img-preview">`)
												.append(`<img src="${e.target.result}" alt="미리보기" class="img-preview">`);
							
							// 미리보기 3-2) 미리보기 영역에 요소 추가
							$("#imgPreviewArea").append(imgPreview);
						}
						
						// 미리보기4) 이미지 파일 읽어오기
						// => 이미지 파일 같은 Base64 형식의 인코딩 된 데이터를 읽어오기 위해 
						//    FileReader 객체의 readAsDataURL() 메서드 활용
						//    (이미지 미리보기나 AJAX 를 활용한 파일 업로드 등에 활용 가능)
						// => 실제 동작 순서는 readAsDataURL() 메서드를 통해 파일 읽어온 후 onload 이벤트 호출됨
						reader.readAsDataURL(file);						
					});
					// --------------------------------------------------
					// 파일 선택 요소 객체의 files 속성에 접근하여 새로운 파일 목록 객체로 업데이트
					$("#custom-file-input")[0].files = newFiles.files;
					
				});
				// =====================================================================
				// 삭제버튼 클릭 이벤트 핸들링
// 				$("#btnRemove").on("click", function() {
// 					// 버튼 요소(메서드 호출된 이벤트 주체 = this) 내의 data-id 속성값 가져오기
// // 					const itemId = $(this).data("id"); // jQuery 방식(대상객체.data("속성명"))
// // 					console.log("btnRemove - data-id값 : " + itemId);
// 					const itemId = this.dataset.id; // 자바스크립트 방식(대상객체.dataset.속성명)
// 					console.log("btnRemove - data-id값222 : " + itemId);
// 				});
					
			});
			
			function confirmDelete() {
// 				const itemId = "[[${itemDTO.id}]]";
				
// 				const itemId = document.querySelector("#itemId").dataset.id;
				const itemId = $("#itemId").data("id");
				console.log("itemId333 : " + itemId);
// 				if(confirm("상품을 삭제하시겠습니까?")) {
// 					location.href = "/items/remove?id=" + itemId;
// 				}
				// ---------------------------------------------
				// AJAX 를 활용하여 삭제 요청 전송
				// 주의! GET 방식을 제외한 나머지 방식으로 AJAX 요청 시 CSRF 토큰값이 자동으로 전송되지 않으므로 포함시켜서 요청을 수행해야한다!
				// => DEBUG: org.springframework.security.web.FilterChainProxy - Securing DELETE /items/21
				//    DEBUG: org.springframework.security.web.csrf.CsrfFilter - Invalid CSRF token found for http://localhost:8085/items/21
				// 1) layout.html 에서 meta 태그 내에 CSRF 토큰값 및 헤더명을 미리 포함시킨 경우 
				//    CSRF 토큰값 포함 태그 : <meta name="_csrf_token" th:content="${_csrf.token}">
				//    CSRF 헤더명 포함 태그 : <meta name="_csrf_headerName" th:content="${_csrf.headerName}">
// 				const csrfToken = $("meta[name='_csrf_token']").attr("content");
// 				const csrfHeaderName = $("meta[name='_csrf_headerName']").attr("content");
				// 2) 서버로부터 전송되는 CSRF 토큰값 및 헤더명을 바로 가져올 경우 
				const csrfToken = "[[${_csrf.token}]]";
				const csrfHeaderName = "[[${_csrf.headerName}]]";
// 				console.log("csrfToken22 : " + csrfToken);
// 				console.log("csrfHeaderName22 : " + csrfHeaderName);
				$.ajax({
					// RESTful API 형식 주소가 아닌 기본 주소 형태로 삭제 요청 전송할 경우 data 속성으로 파라미터 포함
// 					url: "/items/removeAjax",
// 					type: "post",
// 					data: {
// 						itemId
// 					},
					// RESTful API 형식으로 주소를 지정할 경우 삭제는 DELETE 방식의 메서드 활용하며, URL 뒤에 삭제할 번호를 경로 변수 형태로 포함
					url: "/items/" + itemId,
					type: "delete",
					dataType: "json",
					// AJAX 요청 전 먼저 CSRF 값을 서버측으로 전송
					beforeSend: function(xhr) {
						xhr.setRequestHeader(csrfHeaderName, csrfToken);
					},
					success: function(response) {
						
					},
					error: function() {
						alert("삭제 요청 실패!");
					}
				});
			}
		</script>
	</th:block>
</body>
</html>















