<th:block xmlns:th="http://www.thymeleaf.org"
		xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout">
<nav class="nav-bar">
	<!-- 
	[ 사용자 권한에 따른 메뉴 표시 여부 결정 ]
	- 현재 페이지 또는 레이아웃 페이지에 타임리프 스프링 시큐리티 네임스페이스(sec) 추가 필요
	  (레이아웃 페이지에서 네임스페이스 추가 시 현재 페이지에서 경고메세지 출력되지만 사용 가능)
	- 추가된 sec 네임스페이스를 활용하여 권한 체크를 위한 메서드 호출 가능
	- 기본 문법 : sec:authorize="메서드명([파라미터...])" 형태로 지정
	  1) 특정 권한 1개 체크 : sec:authorize="hasAuthority('권한명') 
	  2) 특정 권한 복수개 체크 : sec:authorize="hasAnyAuthority('권한명1', '권한명2', ...) 
	  3) 로그인 한(인증된) 사용자 : sec:authorize="isAuthenticated()"
	  4) 로그인 하지 않은 사용자 : sec:authorize="isAnonymous()"
	  
	-->
	<ul class="nav-center">
		<li><a th:href="@{/}">HOME</a></li>
		<!-- 상품등록 메뉴는 관리자(ROLE_ADMIN), 보조관리자(ROLE_ADMIN_SUB) 에게만 표시 -->
<!-- 		<li sec:authorize="hasAuthority('ROLE_ADMIN')"><a th:href="@{/items/regist}">상품등록</a></li> -->
		<li sec:authorize="hasAnyAuthority('ROLE_ADMIN','ROLE_ADMIN_SUB')"><a th:href="@{/items/regist}">상품등록</a></li>
		<!-- 상품목록 메뉴는 로그인 한 사용자에게만 표시 -->
<!-- 		<li sec:authorize="isAuthenticated()"><a th:href="@{/items/list}">상품목록</a></li> -->
		<li sec:authorize="isAuthenticated()"><a th:href="@{/items}">상품목록</a></li>
	</ul>
	<ul class="nav-right">
		<li sec:authorize="isAnonymous()">
			<a th:href="@{/members/login}">로그인</a>
		</li>
		<li sec:authorize="isAnonymous()">
			<a th:href="@{/members/regist}">회원가입</a>
		</li>
		
		<!-- 
		타임리프 내장객체(#authentication)를 통해 인증 정보 관리 객체(UserDetails 객체 = MemberLoginDTO 객체)에 접근 가능
		#authentication.name : 인증 정보 중 username 값에 접근
		=> UserDetails 객체의 getUsername() 메서드가 자동으로 호출됨
		#authentication.principal.xxx : 인증 정보를 관리하는 UserDetails 객체에 접근
		=> #authentication.principal.name 지정 시 UserDetail 객체의 getName() 메서드가 호출됨
		-->
		<li sec:authorize="isAuthenticated()">
			<a th:href="@{/members/profile}" th:text="|${#authentication.principal.name} (${#authentication.name})|"></a>
		</li>
		<li sec:authorize="isAuthenticated()">
<!-- 			<a th:href="@{/members/logout}">로그아웃</a> -->
			<!-- 주의! 스프링 시큐리티 로그아웃 요청 시 POST 방식 요청 필수! -->
			<a href="javascript:void(0)" onclick="requestLogout()">로그아웃</a>
			<!-- 폼 작성 시 th:action 형태로 주소를 지정하면 요청 정보에 CSRF 값이 자동으로 포함되어 전송됨 -->
			<form th:action="@{/members/logout}" method="post" id="logoutForm"></form>

			<!-- POST 방식 form 태그에서 CSRF 값을 수동으로 포함하여 전송할 경우 -->
<!-- 			<form action="/members/logout" method="post" id="logoutForm"> -->
<!-- 				hidden 속성으로 ${_csrf.xxx} 형태의 이름과 값을 사용하여 CSRF 값 전송 -->
<!-- 				<input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" /> -->
<!-- 			</form> -->
		</li>
	</ul>
	<!-- 푸시(알림) 아이콘 -->
	<div id="alarm-wrapper" sec:authorize="isAuthenticated()">
		<img src="/images/alarm.png" id="alarm-image">
		<span id="alarm-badge"></span>
	</div>
</nav>

<!-- 로그인 한 사용자에게만 스크립트 로딩 -->
<th:block sec:authorize="isAuthenticated()">
	<!-- 웹소켓 관련 라이브러리 -->
	<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
	
	<script>
		// ========================================================
		/*
		[ 웹소켓 설정 ]
		모든 페이지에 공통으로 포함되는 header.html 에서 웹소켓(STOMP) 객체를 전역으로 관리
		각 페이지의 웹소켓 연결 및 해제 등의 공통 작업 처리 담당
		서버 또는 각 개별 페이지에서 전송되는 메세지 처리 담당
		*/
		// 1) STOMP 클라이언트 객체 저장용 변수 선언(=  웹소켓 통신 담당)
		let stompClient = null;
		// 2) STOMP 채널 구독 정보 저장용 변수
		let subscriptions = {};
		// 3) 웹소켓 연결 전 요청된 구독 정보, 메세지 정보들을 임시 저장할 배열(리스트)
		let pendingSubscriptions = [];
		let pendingMessages = [];
		// 4) 기존 구독 정보를 저장할 배열(리스트)
		let subscribes = [];
		// 5) 웹소켓 연결 여부 저장용 변수(플래그)
		let isConnected = false; // 기본값 false 로 초기화(미연결 상태)
		// 6) 웹소켓 재연결 관련 변수
		let reConnectInterval = 3000; // 재접속 수행 간격(3000ms = 3초)
		let reConnecting = false; // 재접속 요청 중복 방지를 위한 플래그
		let retries = 0; // 재접속 시도 횟수 카운팅
		// 7) 사용자 로그아웃 여부 저장용 변수
		let isLogout = false;
		// 8) CSRF 토큰 정보 저장용 변수
// 		const csrfToken = "[[${_csrf.token}]]";
// 		const csrfHeaderName = "[[${_csrf.headerName}]]";
		// -----------------------------------------------------------------------------
		function requestLogout() {
			if(confirm("로그아웃 하시겠습니까?")) {
				document.querySelector("#logoutForm").submit();
				isLogout = true;
			}
		}
		// -----------------------------------------------------------------------------
		$(function() {
			// 페이지 로딩 시 최초 1회 웹소켓 연결 요청
			connectWebSocket();
		});
		
		// 웹소켓 연결을 수행할 메서드 정의
		function connectWebSocket() {
			// 재접속 중복 요청 방지를 위해 reConnecting 변수값이 true 이면 작업 중단
			if(reConnecting) return;
			// 재접속 중복 요청이 아닐 경우 요청중이라는 표시를 reConnecting 변수에 설정
			reConnecting = true;
			// ---------------------
			
			/*
			[ SockJS ]
			- WebSocket 프로토콜이 지원되지 않는 구형 브라우저(IE 등) 등에서도 
			  웹소켓과 동일한 인터페이스로 동작하도록 Fallback 기능 제공하는 라이브러리
			  또한, 서버의 방화벽에 의해서도 웹소켓 관련 포트가 차단되는 경우도 있음
			  => 이러한 상황에서 SockJS 사용할 경우 웹소켓 연결 시도 후 지원되지 않는 프로토콜이거나 포트 차단 시
			     Fallback(차선책) 으로 다른 프로토콜로 자동으로 전환해준다!
			- SockJS 객체를 생성하여 서버 웹소켓 연결 시 서버 엔드포인트와 연결
			  => 이 때, 스프링 웹소켓 설정 클래스에서 엔드포인트 주소를 등록해야함
			  
			*/
			// SockJS 객체 생성하여 웹소켓 연결을 수행할 엔드포인트 주소(http://localhost:8085/ws) 지정
			let socket = new SockJS("/ws");
			  
			// SockJS 에 의해 선택된 웹소켓 관련 프로토콜을 STOMP 프로토콜로 매핑(= 포장)
			stompClient = Stomp.over(socket);
			
			// ------------------------------
			// 기존 구독 정보 복원
			
			// ------------------------------
			// STOMP 를 활용하여 서버와 연결 시도
			stompClient.connect(
				// 헤더 정보 설정(객체 형식으로 설정)
				{
					// CSRF 토큰 정보를 헤더에 포함
// 					csrfHeaderName: csrfToken
					"[[${_csrf.headerName}]]" : "[[${_csrf.token}]]"
				},
				// 웹소켓 연결 성공 시 호출되는 콜백 함수 정의
				function(frame) {
// 					console.log("웹소켓 연결 성공! - ", frame);
					
					// 연결 완료 시 연결 상태 플래그 true 로 변경, 재접속 진행 여부 플래그 false 로 변경, 재접속 카운팅 횟수 초기화
					isConnected = true;
					reConnecting = false;
					retries = 0;
					// ------------------------------
					// 웹소켓 연결 완료 전 이미 요청된 구독 및 메세지 전송 대기열 처리
					
					// ------------------------------
					// 전역 알림(푸시)을 위한 구독 채널("/topic/noti") 구독 요청
					subscribe("noti");
				},
				// 웹소켓 연결 실패 시 호출되는 콜백 함수 정의
				function(error) {
// 					console.log("웹소켓 연결 실패! - ", error);
				}
			);
		} // 웹소켓 연결 메서드(connectWebSocket()) 끝
		// =======================================================================================================
		// 특정 주소(채널)를 구독하는 함수 정의
		// => 첫번째 파라미터(id) : 구독할 주소(/topic/xxx 의 xxx 부분을 전달받음)(필수)
		//    두번째 파라미터(callback) : 구독 요청 처리 후 호출할 콜백 함수(전달되지 않을 수 있음)
		function subscribe(id, callback) {
			// 아직 웹소켓 연결이 되지 않았을 경우 구독 요청 정보를 구독 요청 대기열에 추가
			if(!isConnected) {
				pendingSubscriptions.push({
					id, // id: id 동일
					callback // callback: callback 동일
				});
// 				console.log(pendingSubscriptions);
				// 웹소켓 연결되기 전이므로 대기열에 추가만 하고 이후 작업 진행 중단
				return;
			}
			// ------------------------------
			// 웹소켓이 연결된 상태일 때
			// 요청한 주소가 이미 구독중일 경우 기존 구독 채널 해제(= 중복 구독 제거 위함)
// 			if() {
				
// 			}
			
			// 새로운 구독 정보를 생성하여 구독 요청 및 해당 구독 정보를 구독 정보 저장 객체(subscriptions)에 추가
			// => 구독 요청을 위해 StompClient 객체의 subscribe() 메서드 호출
			// => 기본 문법 : stompClient.subscribe("구독요청주소", 구독 요청 후 해당 주소로 메세지 전송 시 호출될 콜백 함수)
			subscriptions[id] = stompClient.subscribe("/topic/" + id, function(result) {
				// "/topic/xxx" 형태로 구독 요청 전송하고 서버에서 구독 처리를 수행한 이후로 수신되는 모든 메세지가 콜백 함수로 전달됨
				console.log("구독 요청 완료!");
				console.log(result);
			});
			console.log("==========>")
			console.log(subscriptions);
		}
		
	</script>
</th:block>































